SM3算法优化实现说明文档

SM3算法数学基础与理论分析

基本参数定义

设输入消息为M，长度为l比特，其中l小于2的64次方。初始值IV包含8个32位字，分别为7380166f、4914b2b9、172442d7、da8a0600、a96f30bc、163138aa、e38dee4d、b0fb0e4e。常量Tj在j为0到15时等于79cc4519，在j为16到63时等于7a879d8a。

填充函数

对于长度为l的消息M，填充规则分为三步：首先添加一个'1'位，然后添加k个'0'位使得总长度模512余448，最后添加64位的长度字段。最终填充后的消息长度为512的倍数。

消息扩展函数

对于每个512位消息块，首先分解为16个32位字W0到W15。扩展公式为Wj等于P1函数作用于Wj-16异或Wj-9异或W j-3循环左移15位的结果，再异或Wj-13循环左移7位，再异或Wj-6，其中j从16到67。辅助字生成公式为W'j等于Wj异或Wj+4，j从0到63。置换函数P1的定义为X异或X循环左移15位异或X循环左移23位。

压缩函数

对于每轮计算j从0到63，临时变量计算包括SS1等于A循环左移12位加E加Tj循环左移j模32位的结果循环左移7位，SS2等于SS1异或A循环左移12位，TT1等于FF函数作用于A、B、C加D加SS2加W'j，TT2等于GG函数作用于E、F、G加H加SS1加Wj。状态更新为D等于C，C等于B循环左移9位，B等于A，A等于TT1，H等于G，G等于F循环左移19位，F等于E，E等于P0函数作用于TT2。

布尔函数FFj在j为0到15时等于X异或Y异或Z，在j为16到63时等于X与Y或X与Z或Y与Z。GGj在j为0到15时等于X异或Y异或Z，在j为16到63时等于X与Y或非X与Z。置换函数P0定义为X异或X循环左移9位异或X循环左移17位。

多架构优化实现

基础优化策略

寄存器优化

寄存器优化的原理是充分利用CPU寄存器减少内存访问。实现技术包括使用register关键字提示编译器，变量重用和生命周期管理，减少不必要的内存读写操作。相比标准实现性能提升约百分之三十八。

循环展开

循环展开通过消除字置换的4轮组合来提升性能。具体做法是定义一个轮函数宏，然后在主循环中进行4轮组合，消除置换操作。这种优化消除了3个字置换操作，减少中间变量存储，代价是4倍的可执行程序大小。


AVX2指令集优化

AVX2优化的核心思想是并行处理4个字的消息扩展。关键指令包括mm_loadu_si128用于非对齐加载，mm_xor_si128用于向量异或，mm_or_si128用于向量或运算，mm_slli_epi32和mm_srli_epi32用于向量移位。

循环左移的SIMD实现通过将输入向量左移n位和右移32-n位，然后进行或运算来实现。消息扩展优化中，P1函数的SIMD实现通过多个移位和异或操作来并行计算多个字。

AVX512指令集优化

AVX512指令集的新增指令优势包括VPROLD原生循环左移指令和VPTERNLOGD三元逻辑指令。三元逻辑可以用单条指令实现复杂的布尔运算，如X异或Y异或Z对应的立即数为96，X与Y或X与Z或Y与Z对应的立即数为BE，X与Y或非X与Z对应的立即数为CA。

ARM64 NEON优化

架构特点

ARM64架构的寄存器优势包括32个通用寄存器w0到w31，32个NEON寄存器v0到v31每个128位，以及桶形移位寄存器支持。关键指令包括veorq_u32用于向量异或，vshlq_n_u32和vshrq_n_u32用于向量移位，vorrq_u32用于向量或运算。

桶形移位寄存器优化

桶形移位寄存器的优势在于移位和逻辑运算可组合为单条指令。例如w1等于w7异或w13循环左移17位可以用单条指令eor w1, w7, w13, ror #17实现。内联汇编优化可以进一步提升性能，通过直接使用汇编指令来精确控制计算过程。

RFC6962 Merkle树系统设计与实现

设计原则

RFC6962定义了Certificate Transparency系统中使用的Merkle树结构，具有以下特点：叶子节点哈希计算为H(0x00 || leaf_data)，内部节点哈希计算为H(0x01 || left_hash || right_hash)，叶子按哈希值字典序排列，采用完全二叉树结构。

数学模型

树高度计算公式为h等于log2(n)向上取整，其中n为叶子节点数量。证明长度等于树高度h，复杂度为O(log n)。存储复杂度为总节点数约等于2n-1，复杂度为O(n)。

存在性证明算法

证明生成

对于叶子索引i，审计路径包含从叶子到根路径上每个节点的兄弟节点。算法首先设置叶子索引和叶子哈希，然后对每一层进行处理：如果当前节点是左子节点，需要右兄弟节点；如果是右子节点，需要左兄弟节点。最后将当前索引除以2进入上一层。

证明验证

验证算法从叶子哈希开始，对审计路径中的每个节点，根据兄弟节点位置构造输入：如果兄弟是左节点，输入为0x01 || 审计路径节点 || 当前哈希；如果兄弟是右节点，输入为0x01 || 当前哈希 || 审计路径节点。然后计算SM3哈希作为新的当前哈希。最终比较计算结果与根哈希是否相等。

不存在性证明算法

理论基础

不存在性证明基于排序二叉搜索树的性质：如果目标哈希不在树中，则存在前驱和或后继叶子。通过证明前驱和后继的存在性，可以间接证明目标的不存在性。

算法实现

算法首先设置目标哈希，然后在排序的叶子列表中找到前驱和后继。对每个叶子节点，如果其哈希小于目标哈希，则更新前驱索引；否则设置后继索引并退出循环。最后分别生成前驱和后继的存在性证明。

性能优化技术

预计算层级哈希

策略是预计算所有层的节点哈希，避免运行时递归计算。实现方法是首先清空层级哈希存储，然后将叶子节点哈希作为第0层，逐层向上计算父节点哈希，直到只剩一个根节点。优势是将证明生成时间从O(log n)降为O(1)的访问预计算结果，空间代价是O(n)的额外存储。

大规模数据处理

对10万节点的性能测试结果显示：树构建的时间复杂度为O(n log n)，实际性能约2到5秒；证明生成的时间复杂度为O(log n)，实际性能约100微秒；证明验证的时间复杂度为O(log n)，实际性能约50微秒；平均证明长度为17个哈希值。

SM3长度扩展攻击分析


Merkle-Damgård构造漏洞

SM3算法基于Merkle-Damgård构造，存在固有的长度扩展攻击漏洞。状态泄露问题在于哈希输出直接暴露了内部状态。哈希计算过程为H(M)等于compress函数从初始值IV开始，依次处理每个消息块M1到Mn。

攻击条件包括已知H(M)和M的长度，未知M的具体内容，目标是计算H(M || padding || M')，其中padding是标准填充，M'是攻击者选择的扩展内容。

数学描述

设原始消息为M，长度为l位，其哈希值为h等于H(M)等于SM3(M)。攻击者可以构造h'等于H(M || pad(l) || M')等于SM3_continue(h, M', l + |pad(l)|)，其中pad(l)是SM3算法对长度l的标准填充。

攻击实现

 状态恢复

从哈希值恢复内部状态的方法是将32字节的哈希值分解为8个32位字，并进行字节序转换。这样就得到了SM3算法的8个内部状态值。

填充计算

计算原始消息的标准填充需要根据消息长度计算位长度，然后确定填充长度使得总长度模512余448，最后构造填充：首先添加0x80表示'1'位，然后添加0填充，最后添加8字节的长度字段（大端序）。

扩展哈希计算

从恢复的状态继续计算的方法是计算新的总长度为已处理长度加扩展消息长度，应用新的填充到扩展消息，从给定的内部状态开始继续SM3计算过程，最终输出结果。

攻击场景分析

MAC绕过攻击

错误的MAC构造使用MAC等于SM3(key || message)的方式。攻击过程包括四个步骤：攻击者观察到消息和MAC对，攻击者知道密钥长度但不知道密钥内容，攻击者构造扩展消息为原消息加填充加扩展内容，攻击者计算新MAC为length_extend函数作用于原MAC、密钥长度加原消息长度、扩展内容。验证时服务器计算SM3(key || 扩展消息)等于新MAC。

数字签名伪造

在某些错误的签名方案中使用signature等于Sign(SM3(message))的方式。攻击者可以构造扩展消息使得SM3(扩展消息)等于SM3(原消息)，从而伪造签名。

