SM4算法实现与优化

算法基础原理

SM4是中国自主设计的对称加密算法，采用128位分组长度和128位密钥。算法基于32轮的非平衡Feistel网络结构，每轮使用一个轮密钥对数据进行变换。
算法的核心是轮函数T，它由两部分组成：首先通过S盒进行非线性替换，然后进行线性变换。S盒是一个256字节的查找表，将8位输入映射为8位输出。线性变换则是将32位数据与其左循环移位2、10、18、24位的结果进行异或运算。
密钥调度过程将128位主密钥扩展为32个轮密钥，每个轮密钥32位。这个过程使用了系统参数FK和常数CK，确保密钥的充分扩散。

 基础实现思路

最直接的实现方式是严格按照算法标准，对每个32位字进行字节级的S盒查找，然后执行线性变换。这种实现虽然代码清晰易懂，但性能较低，因为每轮需要进行4次S盒查找和多次位运算操作。
在基础实现中，加密过程是将明文分成4个32位字，然后进行32轮迭代。每轮中，取其中3个字进行异或运算并加上轮密钥，结果经过轮函数T处理后与第4个字异或，得到新的字。这个过程体现了Feistel网络的基本结构。

T-Table优化策略

第一个重要优化是T-Table预计算。由于轮函数T由S盒变换和线性变换组成，而这两个变换都是确定性的，我们可以预先计算出所有可能的组合结果。
具体做法是创建4个256项的查找表T0、T1、T2、T3。T0包含对每个字节值执行完整T变换的结果，而T1、T2、T3分别是T0向左循环移位8、16、24位的结果。这样，原本需要4次S盒查找加上复杂线性变换的操作，简化为4次表查找加上4次异或运算。
这种优化显著提升了性能，因为表查找比复杂的位运算更快，而且减少了计算步骤。代价是增加了4KB的内存使用，但这在现代计算机上是可以接受的。

SIMD向量化优化

现代CPU提供了SIMD指令集，可以在一条指令中并行处理多个数据。SM4算法天然适合这种并行化，因为多个独立的数据块可以同时加密。
AESNI实现利用SSE指令集同时处理4个128位数据块。虽然名为AESNI，但这些指令也可以用于其他加密算法。主要思路是将4个数据块分别加载到128位寄存器中，然后并行执行S盒变换和线性变换。
S盒变换的并行化需要特殊处理，因为不能直接对向量进行表查找。一种方法是将向量数据暂时存储到内存中，逐字节查表后再加载回寄存器。另一种更高效的方法是在支持GFNI指令的CPU上，使用专门的有限域运算指令来实现S盒功能。
AVX2实现进一步提升了并行度，使用256位寄存器同时处理8个数据块。这需要更多的寄存器管理和数据重排操作，但可以获得更高的吞吐量。

 自适应选择机制

不同的优化方案适用于不同的场景。对于小数据量，向量化的开销可能超过收益；对于不支持高级指令集的CPU，只能使用基础优化。
自适应实现在运行时检测CPU特性，包括SSE2、AES、AVX2、GFNI等指令集的支持情况。然后根据数据大小和CPU能力选择最合适的实现方式。
选择逻辑是：如果数据量大且CPU支持AVX2，使用8路并行实现；如果数据量中等且支持AESNI，使用4路并行实现；否则使用T-Table实现。对于剩余的不完整块，回退到单块处理。

性能优化细节

内存对齐对SIMD性能至关重要。256位AVX指令要求数据32字节对齐，128位SSE指令要求16字节对齐。代码使用alignas关键字确保临时缓冲区正确对齐。
字节序转换也是一个考虑因素。SM4标准定义了大端字节序，但x86处理器是小端的。代码使用_mm_shuffle_epi8指令高效地进行字节序转换。
循环展开和常量传播是编译器级别的优化。通过减少循环分支和预计算常量表达式，可以进一步提升性能。现代编译器在-O3优化级别下会自动进行这些优化。
